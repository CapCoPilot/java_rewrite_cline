/*
 * This source file was generated by the Gradle 'init' task
 */
package com.javarewrite;

import picocli.CommandLine;
import picocli.CommandLine.Command;
import picocli.CommandLine.Option;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.List;
import java.util.concurrent.Callable;

/**
 * Java Method Replacer - A tool for replacing methods in Java source files while preserving comments.
 */
@Command(
    name = "java-rewrite-cline",
    mixinStandardHelpOptions = true,
    version = "1.0.0",
    description = "Replaces methods in Java source files while preserving comments."
)
public class App implements Callable<Integer> {
    
    @Option(names = {"-f", "--file"}, description = "Path to the Java source file", required = true)
    private File sourceFile;
    
    @Option(names = {"-c", "--class"}, description = "Name of the class containing the method (optional)")
    private String className;
    
    @Option(names = {"-m", "--method"}, description = "Name of the method to replace")
    private String methodName;
    
    @Option(names = {"-n", "--new-method"}, description = "Path to a file containing the new method implementation")
    private File newMethodFile;
    
    @Option(names = {"-l", "--list"}, description = "List all methods in the source file")
    private boolean listMethods;
    
    @Option(names = {"-s", "--string-method"}, description = "New method implementation as a string")
    private String newMethodString;
    
    /**
     * Main entry point for the application.
     */
    public static void main(String[] args) {
        int exitCode = new CommandLine(new App()).execute(args);
        System.exit(exitCode);
    }
    
    /**
     * Executes the command.
     */
    @Override
    public Integer call() throws Exception {
        try {
            MethodReplacer replacer = new MethodReplacer();
            
            if (listMethods) {
                // List all methods in the source file
                List<String> methods = replacer.listMethods(sourceFile.getPath());
                System.out.println("Methods in " + sourceFile.getPath() + ":");
                for (String method : methods) {
                    System.out.println("  - " + method);
                }
                return 0;
            }
            
            // If not listing methods, we need the method name and a new implementation
            if (!listMethods) {
                if (methodName == null) {
                    System.err.println("Error: --method is required when not using --list");
                    return 1;
                }
                
                if (newMethodFile == null && newMethodString == null) {
                    System.err.println("Error: Either --new-method or --string-method must be provided");
                    return 1;
                }
            }
            
            String newMethodCode;
            if (newMethodFile != null) {
                // Read the new method implementation from a file
                newMethodCode = Files.readString(newMethodFile.toPath());
            } else {
                // Use the provided string implementation
                newMethodCode = newMethodString;
            }
            
            // Replace the method
            boolean success = replacer.replaceMethod(
                sourceFile.getPath(),
                className,
                methodName,
                newMethodCode
            );
            
            return success ? 0 : 1;
        } catch (IOException e) {
            System.err.println("Error: " + e.getMessage());
            return 1;
        }
    }
}
